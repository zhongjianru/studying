第 1 章 Python入门
第 2 章 面向对象编程
第 3 章 算法分析
第 4 章 递归
第 5 章 基于数组的序列
第 6 章 栈、队列和双端队列
第 7 章 链表
第 8 章 树
第 9 章 优先级队列
第 10 章 映射、哈希表和跳跃表
第 11 章 搜索树
第 12 章 排序与选择
第 13 章 文本处理
第 14 章 图算法
第 15 章 内存管理和B树

#### 前言

高效数据结构的设计与分析，长期以来一直被认为是计算领域的一个重要主题，同时也是计算机科学与计算机工程本科教学中的核心课程。本书介绍数据结构和算法，包括其设计、分析和实现，可在初级数据结构或中级算法导论课程中使用。我们随后会更详细地讨论如何在这些课程中使用本书。

为了提高软件开发的健壮性和可重用性，我们在本书中采取一致的面向对象的视角。面向对象方法的一个主要思想是数据应该被封装，然后提供访问和修改它们的方法。我们不能简单地将数据看作字节和地址的集合，数据对象是抽象数据类型（Abstract Data Type，ADT）的实例，其中包括可在这种类型的数据对象上执行的操作方法的集合。我们强调的是对于一个特定的 ADT 可能有几种不同的实现策略，并探讨这些选择的优点和缺点。我们几乎为书中的所有数据结构和算法都提供了完整的 Python 实现，并介绍了将这些实现组织为
可重用的组件所需的重要的面向对象设计模式。

通过阅读本书，读者可以：

* 对常见数据集合的抽象有一定了解（如栈、队列、表、树、图）。
* 理解生成常用数据结构的高效实现的算法策略。
* 通过理论方法和实验方法分析算法的性能，并了解竞争策略之间的权衡。
* 明智地利用编程语言库中已有的数据结构和算法。
* 拥有大多数基础数据结构和算法的具体实现经验。
* 应用数据结构和算法来解决复杂的问题。

为了达到最后一个目标，我们在书中提供了数据结构的很多应用实例，包括∶文本处理系统，结构化格式（如HTML）的标签匹配，简单的密码技术，文字频率分析，自动几何布局，霍夫曼编码，DNA序列比对，以及搜索引擎索引。

本书提供一系列丰富的在线资源，可访问以下网站获取：[在线资源](www.wiley.com/college/goodrich)

#### 第 1 章 Python入门

##### Python 概述

* 一种解释语言
* 依赖缩进（一般一条语句写在一行，利用 \ 可以将一条命令写在多行）

##### Python 对象

赋值语句

* 等号左边作为标识符（名称）与等号右边表示的对象相关联

标识符

* 大小写敏感，不能以字母开头，不能使用保留字作为标识符
* 每个标识符与其所引用的对象的内存地址隐式相关联
* 可以分配给一个名为 None 的特殊对象（与 Java 或 C++ 中空引用的目的相似）
* 动态类型语言，标识符的数据类型不需要实现声明（与 Java 或 C++ 不同）
* 标识符可以与任何类型的对象相关联，并可以重新分配给另一个对象
* 虽然标识符没有被声明为确切的类型，但它所引用的对象有一个明确的类型
* 可以通过向现有对象指定第二个标识符来建立别名，一旦建立了别名，两个名称都可用来访问底层对象
  1. 使用一个别名而通过另一个别名改变对象
  2. 如果对象的一个别名被复制语句重新赋予了新的值，并不影响已存在的对象

内置类

* 如果类的每个对象在实例化时有一个固定的值，并且在随后的操作中不会被改变，那么就是不可变的类
  1. 不可变类：bool、int、float、tuple、str、frozenset
  2. 可变类：list、set、dict

* 所有的类都支持传统构造函数形式创建基于一个或多个现有值的实例，传统构造函数如 bool()、int()、float() 等

* bool
  1. 就数字而言，如果为零则为 False 否则为 True
  2. 对于序列和其他容器类型（如字符串和列表），如果是空为 False 非空则为 True
  3. 也就是说，可以使用非布尔类型的值作为控制结构的条件

* int
  1. 不像 Java 和 C++ 支持不同精度的不同整数类型（int、short、long），Python 会根据其整数的大小自动选择内部表示的方式
  2. 可以使用二进制（以0b开头）、八进制（以0o开头）或者十六进制（以0x开头）来表示一个整型值
  3. 构造函数 int() 可以用于构造基于另一类型值的整数值，例如 int(f) 得到浮点数 f 的整数部分，还可以把进制作为第二个可选参数传入，如果传入的参数无法解析为整数，将会产生 ValueError 异常

* float
  1. Python 中唯一的浮点类型，使用固定精度表示，更像是 double 型
  2. 可以使用小数或者科学计数法表示，如 2. 或者 6.022e23

* 序列类型：list、tuple、str，代表许多值的集合，集合中值的顺序很重要

* list
  1. 表示任意对象的序列，列表的元素可以是任意对象（包括 None 对象）
  2. 列表是基于数组的序列，采用**零索引**，因此一个长度为 n 的列表包含索引号从 0 到 n-1 的对象
  3. 具备随着需求动态扩展和收缩存储容量的能力
  4. 使用字符 [] 作为列表的分隔符，[] 本身表示一个空列表
  5. list() 构造函数默认产生一个空列表，list('hello') 产生一个单个字符的列表（h、e、l、l、o）

* tuple
  1. list 的一个不可变的版本，可以看做列表类一种简化的内部表示
  2. 使用 () 表示元组，() 代表一个空的元组。为了表示只有一个元素的元组，该元素之后必须有一个逗号并在圆括号之内，例如 (17,)

* str
  1. 文本字符**不可变**的序列，字符可以看做长度为 1 的字符串
  2. 可以用单引号或者双引号括起来（在序列中使用另一个引号字符作为一个实际字符，如 "Don't worry"），反斜杠也可以实现这个目的（如 'C:\\Python\\' 实际上要表达的是一个反斜杠作为路径），其他常用的转义字符有 \n（换行符）和 \t（制表符）
  3. 在字符串的收尾使用连续三个单引号或者双引号，使得换行符可以在字符串中自然出现，而不用使用转义字符（三引号表示段落，可以直接使用换行）

* set
  1. 许多元素的集合，集合中没有重复的元素，而且元素之间没有内在联系，如 set('hello') 产生集合 {'h','e','l','o'}
  2. 与列表相反，使用集合的主要优点是有一个高度优化的方法来检查特定元素是否包含在集合内（基于散列表）
  3. 没有特定顺序
  4. 只有不可变类型的实例才能被添加到集合
  5. frozenset 是集合类型的一种不可变的形式
  6. 使用 {} 作为集合的分隔符，但是 {} 并不表示一个空集合，而是一个空字典，构造函数 set() 返回一个空集合

* dict
  1. 表示字典或者映射，即从一组不同的键中找到对应的值
  2. 字典也使用 {} 表示，因为在 Python 中字典类型是早于集合类型出现的，{} 表示一个空字典，非空字典用逗号分隔一系列的键值对表示，例如 {'ga':'Irish','de':'German'}
  3. 构造函数 dict() 接受一个现有的映射作为参数，也可以接受一系列键值对作为参数，例如 dict(pairs) 中 pairs=[('ga','Irish'),('de'.'German')]

##### 表达式、运算符和优先级

* 逻辑运算符
  1. not 逻辑非
  2. and 逻辑与（短路保护）
  3. or  逻辑或（短路保护）

* 相等运算符
  1. is     同一实体
  2. is not 不同实体
  3. ==     等价
  4. !=     不等价

* 比较运算符
  1. <   小于
  2. <=  小于等于
  3. \>  大于
  4. \>= 大于等于

* 算术运算符
  1. \+  加
  2. \-  减
  3. \*  乘
  4. /   除
  5. //  整数除法
  6. %   模运算符

* 位运算符
  1. ~   取反（前缀一元运算符）
  2. &   按位与
  3. |   按位或
  4. ^   按位异或
  5. <<  左移位，用零填充
  6. \>> 右移位，按符号位填充

* 序列运算符
  1. s[j]                 # 索引下表为j的元素
  2. s[start:stop]        # 切片操作得到索引为[start,stop)的序列
  3. s[start:stop:step]   # 切片操作，步长为step
  4. s + t                # 序列的连接
  5. k * s                # 序列s连接k次
  6. val in s             # 检查元素val在序列s中
  7. val not in s         # 检查元素val不在序列s中

* 序列类型支持
  1. s==t  相等（每一个元素对应相等）
  2. s!=t  不相等
  3. s< t  字典序的小于
  4. s<=t  字典序的小于或等于
  5. s> t  字典序的大于
  6. s>=t  字典序的大于或等于

* 集合运算符
  1.  key in s            # 检查key是s的成员
  2.  key not in s        # 检查key不是s的成员
  3.  s1==s2              # s1等价于s2
  4.  s1!=s2              # s1不等价于s2
  5.  s1<=s2              # s1是s2的子集
  6.  s1< s2              # s1是s2的真子集
  7.  s1>=s2              # s1是s2的超集
  8.  s1> s2              # s1是s2的真超集（s1不等于s2）
  9.  s1 | s2             # s1与s2的并集
  10. s1 & s2             # s1与s2的交集
  11. s1 - s2             # s1与s2的差集
  12. s1 ^ s2             # 对称差分（该集合中的元素在s1和s2的其中之一）

* 字典运算符
  1. d[key]               # 给定键key所关联的值
  2. d[key]==value        # 设置（或充重置）与给定的键相关联的值
  3. del d[key]           # 从字典中删除键及其关联的值
  4. key in d             # 检查key是d的成员
  5. key not in d         # 检查key不是d的成员
  6. d1==d2               # d1等价于d2
  7. d1!=d2               # d1不等价于d2

* 拓展赋值运算符
  1. count+=5

* 复合表达式和运算符优先级
