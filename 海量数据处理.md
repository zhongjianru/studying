- [补充：[语言]Java](https://liaoxuefeng.com/books/java/introduction/index.html)
- [补充：[语言]Scala](http://runoob.com/scala/scala-intro.html)
- [补充：[算法]基础](https://www.hello-algo.com/chapter_hello_algo/)
- [补充：[算法]刷题](https://labuladong.online/algo/intro/core-intro/)
- [补充：[面试]大数据常见面试题1](https://zhuanlan.zhihu.com/p/350209856)
- [补充：[面试]大数据常见面试题2](https://zhuanlan.zhihu.com/p/428400306)
- [补充：[面试]海量数据处理](https://cloud.tencent.com/developer/article/1064552)
- [补充：[面试]海量数据去重](https://mp.weixin.qq.com/s/thriUUSWMnHsx3sU2Og_LA)

- [参考：面试现场：海量数据中的TOPK问题](https://www.cnblogs.com/luedong/p/16006420.html)
- [参考：面试经典的海量数据处理（TOPK）](https://blog.csdn.net/juzihongle1/article/details/70212243)
- [参考：海量数据中找出前k大数（topk问题）](https://zhuanlan.zhihu.com/p/119385223)

**1、40亿个QQ号如何去重**
- [题解](https://www.cnblogs.com/chenfx/p/15710156.html)
```
2^10=1024≈1000
2^20≈100万
2^30≈10亿
2^32≈40亿，所以32位可以表示最大40亿整数，即40亿个QQ号
快速计算：1024*1024*1024=2^30约为10亿

哈希表所需大小：
40亿*32位/8位(一个字节)/1024(KB)/1024(MB)/1024(GB) ≈ 14.9G
bitmap所需大小：
40亿*1位/8位(一个字节)/1024(KB)/1024(MB)/1024(GB) ≈ 0.466G，只需要不到500M，符合题目要求

按字节分组：每8位一个字节，即8个QQ号作为一组（用整型分组同理，32个一组）
第1组：[0-7]下标代表QQ号1-8
第2组：[8-15]下标代表QQ号9-16
...

分组 = QQ号/8向下取整 +1
分组下标 = QQ号%8取余
对应元素 = 组号*每个组大小+分组下标（相对偏移量）

总结常见存储方式：
QQ号：整型存储，理论最大=2^32≈43亿
IP地址：整型存储，共四段，每段8位，理论最大值≈43亿
整型：4个字节
```

**2、求出现次数最多的K个（topK）/找出最大的K个数同理**
```
解法：分治法+哈希表+小顶堆：
分治法：限制文件大小（比如100K）将数据按照主键使用哈希函数分割到不同文件里
如果文件超出大小限制，再继续分割，直到符合大小限制，保证同一元素（或者同一范围内的元素）只会在同一个文件中出现
（整数就用取模的方法，字符串用映射，或者想办法转换成整数，比如url可以转换成ip）
哈希表：将计数结果维护到哈希表
小顶堆：采用容量为K的小顶堆，统计每个文件的topK，再将所有局部topK维护到一个小顶堆，得出最终的topK
（最小堆保存K个目前的最大值，堆顶数字最小，每个元素与堆顶比较，比堆顶小就不处理，比堆顶大的元素就压到堆里）
或者多路归并：将每个文件的topK拿出来一起排序，得出最终的topK
```

**3、求重复/不重复/没出现过/数据去重**
```
(1)2.5亿个整数，求出不重复的
解法：bitmap（纯数字建议使用bitmap）
用整型表示数字，另外分配2bit用来做计数
没出现过就是00，不重复就是01，重复就是10/11/或者更多
（如果计数位数不够，多出来的次数可以不用再加）
去重就是按顺序把计数>0的下标输出就行

(2)40亿个非负整数，找没出现过的（一个就行）
解法：分治法+bitmap：
将40亿个数字按照数字范围分组，分组数量由可用的内存决定（10M/1G解法不同）
10M解法：将组内的数字存到哈希集合里，计算哈希集合大小，如果少于组范围，则该组至少有一个数字没出现过，分组后利用bitmap查找没出现的数字
1G解法：直接用bitmap解决，不用分治

(3)40亿个不重复的整数，给定一个数，判断是否在这批数字里面
解法：二分查找
将40亿个数字按照第一位数字是0或1分组，再按第二位数字分组，以此类推，分组的时间复杂度为O(nlogn)

(4)在多个文件中找出所有重复元素
解法：分治法
分割文件：将两个文件的元素按照同样的哈希函数（比如%1000）分发到不同文件里（同上面处理方法）
只有同样编号的文件才可能拥有同样的元素
同样编号的小文件中，读取文件1的元素到哈希集合，再遍历文件2中的元素是否存在于哈希集合中
```

**4、排序**
```
解法：分治法
分割文件：（同上面处理方法）
文件内排序：选择排序方法
文件间归并：类似合并两个数组，用双指针对比每个组的元素，最小的放到结果里，指针往后走一格，依次操作完
```

**5、求中位数**
```
双堆：一个最大堆与一个最小堆结合，可以用来维护中位数。
多次划分：将数字按照大小分组，统计组内数字个数，逐步缩小范围，确定中位数存在于哪个组，是组内的第几大数
```
